Fork/Join Framework (RecursiveAction, RecursiveTask, ForkJoinPool) :
Utilisé pour la division récursive d'une tâche en sous-tâches, adapté aux problèmes qui peuvent être résolus de manière récursive.
Exemple : Calcul parallèle de la somme d'un tableau.

ExecutorService (ThreadPoolExecutor, Executors) :
Utilisé pour gérer l'exécution asynchrone de tâches en utilisant des threads.
Exemple : Exécution simultanée de plusieurs tâches indépendantes.

CountDownLatch :
Utilisé lorsque vous avez besoin qu'un ou plusieurs threads attendent que d'autres threads aient terminé avant de continuer.
Exemple : Coordonner le départ d'une famille pour un voyage une fois que tous les membres sont prêts.

CyclicBarrier :
Utilisé lorsque vous avez besoin que plusieurs threads se synchronisent à un point donné pour continuer ensemble.
Exemple : Coordonner plusieurs équipes dans une course à étapes.

Semaphore :
Utilisé pour contrôler l'accès simultané à une ressource partagée par un nombre limité de threads.
Exemple : Contrôle de l'accès à un nombre limité de bols de nourriture pour des chiens dans une étable.

AtomicIntegerArray :
Utilisé lorsque vous avez besoin d'opérations atomiques sur un tableau d'entiers.
Exemple : Incrémentation atomique des éléments d'un tableau.

Exchanger :
Utilisé lorsque deux threads doivent échanger des données entre eux à un point de rencontre.
Exemple : Échange de voitures entre les clients et le garage pendant une réparation.

Phaser :
Utilisé lorsque vous avez besoin de synchroniser plusieurs threads à plusieurs points de rendez-vous dans un cycle.
Exemple : Coordonner les étapes d'un voyage à vélo en famille.
Choisissez la classe ou le mécanisme qui convient le mieux à votre problème spécifique en fonction des fonctionnalités offertes par chacun.


exemple de reentrant lock, liste partagée entre deux threads

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class SharedListProcessor extends Thread {
    private List<Integer> sharedList;
    private Lock lock;

    public SharedListProcessor(List<Integer> sharedList, Lock lock) {
        this.sharedList = sharedList;
        this.lock = lock;
    }

    public void run() {
        for (int i = 0; i < 5; i++) {
            try {
                lock.lock();
                sharedList.add(i);
                System.out.println(Thread.currentThread().getName() + " added: " + i);
            } finally {
                lock.unlock();
            }
        }
    }
}

public class ReentrantLockExample {
    public static void main(String[] args) {
        List<Integer> sharedList = new ArrayList<>();
        Lock lock = new ReentrantLock();

        SharedListProcessor thread1 = new SharedListProcessor(sharedList, lock);
        SharedListProcessor thread2 = new SharedListProcessor(sharedList, lock);

        thread1.start();
        thread2.start();

        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Shared List: " + sharedList);
    }
}


`ReadWriteLock` est une interface Java qui permet d'optimiser la gestion des accès en lecture et en écriture à une ressource partagée entre plusieurs threads. Elle permet à plusieurs threads de lire la ressource simultanément, mais garantit qu'un seul thread peut écrire dans la ressource à la fois. Voici quelques situations où l'utilisation de `ReadWriteLock` peut être appropriée :

1. **Lecture intensive, écriture peu fréquente** : Si la ressource est principalement lue par plusieurs threads, mais rarement mise à jour, l'utilisation de `ReadWriteLock` permet d'améliorer les performances en permettant la lecture simultanée par plusieurs threads.

2. **Réduction du verrouillage excessif** : Par rapport à l'utilisation d'un verrou traditionnel (par exemple, `ReentrantLock`) pour synchroniser à la fois la lecture et l'écriture, l'utilisation de `ReadWriteLock` peut réduire le verrouillage excessif en autorisant la lecture simultanée.

3. **Amélioration de la scalabilité** : L'utilisation de `ReadWriteLock` peut améliorer la scalabilité de l'application en permettant à plusieurs threads de lire la ressource en parallèle, ce qui peut réduire les temps d'attente et améliorer les performances globales.

4. **Protection contre les conditions de course en écriture** : En limitant l'accès en écriture à un seul thread à la fois, `ReadWriteLock` protège contre les conditions de course en écriture qui pourraient survenir lorsque plusieurs threads tentent de modifier la ressource simultanément.

En résumé, `ReadWriteLock` est particulièrement utile dans les cas où la lecture de la ressource est fréquente par rapport à l'écriture, et où la parallélisation de la lecture peut améliorer les performances globales de l'application.

`ReentrantReadWriteLock` est une implémentation de l'interface `ReadWriteLock` dans Java, qui fournit un mécanisme de verrouillage pour la gestion concurrente d'une ressource partagée, où plusieurs threads peuvent lire la ressource en même temps, mais l'accès en écriture est exclusif.

Voici quand utiliser `ReentrantReadWriteLock` :

1. **Accès intensif en lecture, accès en écriture moins fréquent** : Comme pour `ReadWriteLock`, `ReentrantReadWriteLock` est adapté aux situations où la ressource est principalement lue par plusieurs threads mais est rarement modifiée.

2. **Lecture optimisée** : `ReentrantReadWriteLock` offre des performances améliorées par rapport à l'utilisation d'un verrou standard pour la lecture et l'écriture. Il permet à plusieurs threads de lire la ressource en même temps, ce qui peut améliorer les performances dans les scénarios où la lecture est fréquente.

3. **Protection contre les conditions de course en écriture** : Comme avec `ReadWriteLock`, `ReentrantReadWriteLock` protège contre les conditions de course en écriture en permettant à un seul thread d'écrire dans la ressource à la fois.

4. **Compatibilité avec la réentrance** : Comme son nom l'indique, `ReentrantReadWriteLock` est réentrant, ce qui signifie qu'un thread qui détient déjà le verrou en lecture peut également acquérir le verrou en écriture, et vice versa, sans se bloquer.

5. **Flexibilité pour les cas où la réservation de verrou n'est pas nécessaire** : Contrairement à certains autres verrous, `ReentrantReadWriteLock` ne nécessite pas nécessairement la réservation d'un verrou avant de le libérer. Cette flexibilité peut être utile dans certains cas d'utilisation.

En résumé, `ReentrantReadWriteLock` est une option appropriée lorsque vous avez une ressource partagée avec une charge de lecture élevée et une charge d'écriture modérée, et que vous avez besoin d'une gestion de verrouillage concurrentielle et efficace.

Les `Lock.Condition` sont des objets associés à un verrou (`Lock`) qui permettent à un thread d'attendre qu'une certaine condition soit satisfaite avant de continuer son exécution. Ils sont utilisés en conjonction avec un verrou pour permettre une coordination plus fine entre les threads.

Voici quelques situations où vous pourriez utiliser `Lock.Condition` :

1. **Coordination entre threads** : Si un thread doit attendre qu'une certaine condition soit remplie avant de poursuivre son exécution, vous pouvez utiliser `Lock.Condition` pour suspendre son exécution jusqu'à ce que cette condition soit satisfaite.

2. **Synchronisation de tâches** : Vous pouvez utiliser `Lock.Condition` pour synchroniser l'exécution de plusieurs threads dans un ordre spécifique ou pour contrôler le flux d'exécution en fonction de certaines conditions.

3. **Gestion de files d'attente personnalisées** : Les conditions peuvent être utilisées pour implémenter des files d'attente personnalisées, où les threads peuvent attendre dans une file d'attente spécifique jusqu'à ce qu'une condition particulière soit remplie.

4. **Communication entre threads** : Les conditions peuvent être utilisées pour faciliter la communication entre threads en leur permettant d'attendre la notification d'un autre thread avant de poursuivre leur exécution.

Voici un exemple simple d'utilisation de `Lock.Condition` :

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class SharedResource {
    private boolean conditionMet = false;
    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();

    public void waitForCondition() throws InterruptedException {
        lock.lock();
        try {
            while (!conditionMet) {
                condition.await();
            }
            System.out.println("Condition is met!");
        } finally {
            lock.unlock();
        }
    }

    public void signalCondition() {
        lock.lock();
        try {
            conditionMet = true;
            condition.signal();
        } finally {
            lock.unlock();
        }
    }
}

public class ConditionExample {
    public static void main(String[] args) {
        SharedResource resource = new SharedResource();

        Thread waiterThread = new Thread(() -> {
            try {
                resource.waitForCondition();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        Thread signalerThread = new Thread(() -> {
            try {
                Thread.sleep(2000); // Simulate some delay
                resource.signalCondition();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        waiterThread.start();
        signalerThread.start();
    }
}
```

Dans cet exemple, un thread attend que la condition soit satisfaite à l'aide de `waitForCondition()`, tandis qu'un autre thread signale la condition à l'aide de `signalCondition()`.



Les `Executor` sont utilisés dans Java pour gérer l'exécution de tâches de manière asynchrone, souvent dans le contexte de programmation multithreadée. Voici quelques situations où vous pourriez utiliser des `Executor` :

1. **Exécution de tâches asynchrones** : Si vous avez des tâches qui peuvent être exécutées de manière asynchrone, comme des appels réseau, des calculs intensifs ou des opérations sur des fichiers, vous pouvez utiliser un `Executor` pour les exécuter en arrière-plan sans bloquer le thread principal.

2. **Gestion des threads** : Les `Executor` simplifient la gestion des threads en fournissant une interface de haut niveau pour l'exécution de tâches. Vous n'avez pas besoin de créer et de gérer manuellement des threads, ce qui réduit les risques d'erreurs liées à la gestion des threads.

3. **Contrôle du nombre de threads** : Les `Executor` permettent de contrôler facilement le nombre de threads utilisés pour exécuter les tâches. Vous pouvez utiliser des implémentations spécifiques d'`Executor`, comme `ThreadPoolExecutor`, pour configurer le pool de threads en fonction des besoins de votre application.

4. **Gestion de la file d'attente des tâches** : Les `Executor` fournissent une file d'attente pour les tâches en attente d'exécution. Cela permet de lisser la charge de travail et d'éviter la surcharge des ressources système en cas de forte demande.

5. **Gestion des erreurs** : Les `Executor` fournissent des mécanismes pour gérer les erreurs survenues lors de l'exécution des tâches, ce qui facilite la gestion des exceptions dans les applications multithreadées.

6. **Planification des tâches récurrentes** : Certains `Executor` offrent la possibilité de planifier l'exécution de tâches de manière récurrente, ce qui peut être utile pour les tâches périodiques telles que la génération de rapports ou la maintenance des données.

En résumé, vous pouvez utiliser des `Executor` chaque fois que vous avez besoin d'exécuter des tâches de manière asynchrone, de contrôler le nombre de threads utilisés pour exécuter ces tâches et de gérer les erreurs qui peuvent survenir pendant leur exécution. Ils offrent une abstraction puissante pour la gestion des threads et facilitent le développement d'applications multithreadées robustes et performantes.




Voici un exemple où nous utilisons `Callable` pour calculer la somme des éléments d'un tableau de manière asynchrone à l'aide d'un `ExecutorService` :

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

class SumCalculator implements Callable<Integer> {
    private int[] array;
    private int startIndex;
    private int endIndex;

    public SumCalculator(int[] array, int startIndex, int endIndex) {
        this.array = array;
        this.startIndex = startIndex;
        this.endIndex = endIndex;
    }

    public Integer call() {
        int sum = 0;
        for (int i = startIndex; i < endIndex; i++) {
            sum += array[i];
        }
        return sum;
    }
}

public class CallableExample {
    public static void main(String[] args) {
        int[] array = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        int numThreads = 4;
        ExecutorService executor = Executors.newFixedThreadPool(numThreads);

        int blockSize = array.length / numThreads;
        int startIndex = 0;
        int endIndex = blockSize;

        // Soumission des tâches Callable à l'ExecutorService
        Future<Integer>[] futures = new Future[numThreads];
        for (int i = 0; i < numThreads; i++) {
            if (i == numThreads - 1) {
                endIndex = array.length;
            }
            SumCalculator calculator = new SumCalculator(array, startIndex, endIndex);
            futures[i] = executor.submit(calculator);
            startIndex = endIndex;
            endIndex += blockSize;
        }

        // Attente et récupération des résultats
        int totalSum = 0;
        try {
            for (Future<Integer> future : futures) {
                totalSum += future.get();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        System.out.println("Total sum: " + totalSum);

        // Arrêt de l'ExecutorService
        executor.shutdown();
    }
}
```

Dans cet exemple :

- Nous créons une classe `SumCalculator` qui implémente `Callable<Integer>`. Cette classe calcule la somme des éléments d'un sous-tableau.
- Nous créons un `ExecutorService` avec un pool de threads de taille fixe.
- Nous découpons le tableau en plusieurs sous-tableaux et soumettons chaque tâche `SumCalculator` à l'`ExecutorService` pour calculer la somme de chaque sous-tableau.
- Nous utilisons `Future.get()` pour attendre que chaque tâche se termine et obtenir le résultat.
- Nous calculons la somme totale à partir des résultats partiels des tâches et affichons le résultat final.


Voici un exemple simple d'une file d'attente avec verrouillage en Java, où nous avons un producteur qui produit des éléments dans la file d'attente et un consommateur qui les consomme :

```java
import java.util.LinkedList;
import java.util.Queue;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class BlockingQueue<T> {
    private Queue<T> queue;
    private int capacity;
    private Lock lock;
    private Condition notFull;
    private Condition notEmpty;

    public BlockingQueue(int capacity) {
        this.capacity = capacity;
        queue = new LinkedList<>();
        lock = new ReentrantLock();
        notFull = lock.newCondition();
        notEmpty = lock.newCondition();
    }

    public void enqueue(T item) throws InterruptedException {
        lock.lock();
        try {
            while (queue.size() == capacity) {
                notFull.await();
            }
            queue.offer(item);
            notEmpty.signal();
        } finally {
            lock.unlock();
        }
    }

    public T dequeue() throws InterruptedException {
        lock.lock();
        try {
            while (queue.isEmpty()) {
                notEmpty.await();
            }
            T item = queue.poll();
            notFull.signal();
            return item;
        } finally {
            lock.unlock();
        }
    }
}

class Producer implements Runnable {
    private BlockingQueue<Integer> queue;

    public Producer(BlockingQueue<Integer> queue) {
        this.queue = queue;
    }

    public void run() {
        try {
            for (int i = 0; i < 10; i++) {
                System.out.println("Producing: " + i);
                queue.enqueue(i);
                Thread.sleep(1000); // Simulate some work
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

class Consumer implements Runnable {
    private BlockingQueue<Integer> queue;

    public Consumer(BlockingQueue<Integer> queue) {
        this.queue = queue;
    }

    public void run() {
        try {
            for (int i = 0; i < 10; i++) {
                int item = queue.dequeue();
                System.out.println("Consuming: " + item);
                Thread.sleep(2000); // Simulate some work
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

public class BlockingQueueExample {
    public static void main(String[] args) {
        BlockingQueue<Integer> queue = new BlockingQueue<>(5);

        Thread producerThread = new Thread(new Producer(queue));
        Thread consumerThread = new Thread(new Consumer(queue));

        producerThread.start();
        consumerThread.start();
    }
}
```

Dans cet exemple :

- `BlockingQueue` est une file d'attente avec verrouillage qui peut enregistrer un nombre fixe d'éléments.
- La classe `Producer` produit des éléments et les ajoute à la file d'attente à l'aide de la méthode `enqueue()`.
- La classe `Consumer` consomme des éléments de la file d'attente à l'aide de la méthode `dequeue()`.
- Les threads `Producer` et `Consumer` sont créés et démarrés, et ils produisent et consomment des éléments de manière asynchrone, synchronisée par le verrou de la file d'attente.


Bien sûr ! Voici un exemple pratique où nous utilisons le Singleton pour gérer une connexion à une base de données dans une application Java :

```java
// Classe Singleton de gestion de la connexion à la base de données
public class DatabaseConnection {
    // Instance unique de la classe Singleton
    private static DatabaseConnection instance;

    // Attributs de connexion à la base de données
    private String url;
    private String username;
    private String password;

    // Constructeur privé pour empêcher l'instanciation depuis l'extérieur de la classe
    private DatabaseConnection() {
        // Initialisation des attributs de connexion (exemple)
        url = "jdbc:mysql://localhost:3306/mydatabase";
        username = "root";
        password = "password";
    }

    // Méthode statique pour accéder à l'instance unique du Singleton
    public static synchronized DatabaseConnection getInstance() {
        // Crée l'instance si elle n'existe pas encore
        if (instance == null) {
            instance = new DatabaseConnection();
        }
        return instance;
    }

    // Méthode pour établir la connexion à la base de données (exemple)
    public void connect() {
        System.out.println("Connecting to database...");
        // Code pour établir la connexion à la base de données
        System.out.println("Connected to database: " + url);
    }

    // Autres méthodes pour manipuler la connexion à la base de données
    // ...
}

// Exemple d'utilisation du Singleton dans une application
public class Main {
    public static void main(String[] args) {
        // Accès à l'instance unique du Singleton
        DatabaseConnection databaseConnection = DatabaseConnection.getInstance();

        // Connexion à la base de données
        databaseConnection.connect();
    }
}
```

Dans cet exemple :

- La classe `DatabaseConnection` représente le Singleton qui gère la connexion à la base de données.
- La méthode `getInstance()` fournit un point d'accès global à l'instance unique de `DatabaseConnection`. Si aucune instance n'existe encore, cette méthode crée une nouvelle instance en appelant le constructeur privé.
- La méthode `connect()` est un exemple d'une opération que vous pourriez effectuer avec votre connexion à la base de données. Dans cet exemple, elle affiche simplement un message de connexion réussie.
- Dans la classe `Main`, nous accédons à l'instance unique de `DatabaseConnection` en appelant `DatabaseConnection.getInstance()`, puis nous utilisons cette instance pour établir une connexion à la base de données en appelant `connect()`.

Le Proxy Pattern est un patron de conception structurel qui permet de contrôler l'accès à un objet en agissant comme une interface de remplacement ou un point d'accès à cet objet. Il peut être utilisé pour ajouter une couche d'abstraction et de contrôle supplémentaire autour d'un objet réel, en fournissant une interface similaire à celle de l'objet réel.

Voici les principaux acteurs impliqués dans le Proxy Pattern :

1. **Sujet (Subject)** : C'est l'interface commune entre le client et le proxy, décrivant les opérations que le client peut appeler sur l'objet réel.

2. **Proxy** : Il implémente l'interface du sujet et contrôle l'accès à l'objet réel. Le proxy intercepte les appels du client et peut effectuer des opérations supplémentaires avant ou après de rediriger les appels à l'objet réel.

3. **Objet réel (Real Subject)** : C'est l'objet réel qui effectue le travail réel, mais qui est caché derrière le proxy. Le client n'a pas besoin de connaître l'existence de l'objet réel.

Le Proxy Pattern est utile dans les cas suivants :

- **Contrôle d'accès** : Pour limiter l'accès à certaines fonctionnalités de l'objet réel.
- **Chargement paresseux (Lazy Loading)** : Pour retarder le chargement d'un objet lourd en mémoire jusqu'à ce qu'il soit vraiment nécessaire.
- **Mise en cache** : Pour mettre en cache les résultats des opérations coûteuses et les fournir directement si elles ont déjà été calculées.
- **Journalisation ou surveillance** : Pour journaliser les appels ou surveiller les opérations effectuées sur l'objet réel.

Voici un exemple d'utilisation du Proxy Pattern en Java pour implémenter un proxy pour l'accès à des fichiers sur le système de fichiers :

```java
// Sujet (interface)
interface File {
    void read();
}

// Objet réel
class RealFile implements File {
    private String fileName;

    public RealFile(String fileName) {
        this.fileName = fileName;
        loadFromDisk();
    }

    private void loadFromDisk() {
        System.out.println("Loading file: " + fileName);
    }

    public void read() {
        System.out.println("Reading file: " + fileName);
    }
}

// Proxy
class ProxyFile implements File {
    private String fileName;
    private RealFile realFile;

    public ProxyFile(String fileName) {
        this.fileName = fileName;
    }

    public void read() {
        // Crée l'objet réel lors du premier appel
        if (realFile == null) {
            realFile = new RealFile(fileName);
        }
        // Appelle la méthode read() de l'objet réel
        realFile.read();
    }
}

// Exemple d'utilisation du Proxy Pattern
public class ProxyPatternExample {
    public static void main(String[] args) {
        // Utilisation du proxy pour accéder à un fichier
        File file = new ProxyFile("example.txt");

        // Lecture du fichier
        file.read();
    }
}
```

Dans cet exemple :

- `File` est l'interface commune entre le client et le proxy.
- `RealFile` est l'objet réel qui représente un fichier sur le système de fichiers.
- `ProxyFile` est le proxy qui contrôle l'accès au fichier réel. Il intercepte les appels de lecture et charge le fichier réel lors du premier appel à la méthode `read()`.
- Dans la classe `ProxyPatternExample`, nous utilisons le proxy pour accéder à un fichier, en utilisant l'interface commune `File`. Lorsque nous appelons la méthode `read()` sur le proxy, il charge le fichier réel si nécessaire, puis appelle la méthode `read()` sur l'objet réel pour lire le fichier.



Le Observer Pattern est un patron de conception comportemental qui permet à un objet, appelé le sujet (ou observable), de publier des changements à d'autres objets, appelés les observateurs, de manière automatique. Ce pattern est utilisé lorsque vous avez une relation un-à-plusieurs entre les objets, de sorte que lorsque l'état d'un objet change, tous ses observateurs sont notifiés et mis à jour automatiquement.

Voici les acteurs principaux du Observer Pattern :

1. **Sujet (Observable)** : Il est responsable de maintenir une liste d'observateurs et de les notifier lorsque son état change.

2. **Observateur (Observer)** : Il définit une interface de mise à jour pour les objets qui doivent être notifiés des changements d'état du sujet.

3. **Observateurs concrets (Concrete Observers)** : Ils implémentent l'interface Observateur et réagissent aux notifications émises par le sujet.

Le Observer Pattern est utilisé dans de nombreuses situations, telles que la mise à jour de l'interface utilisateur en réponse aux changements de modèle, la mise en œuvre de la publication-abonnement, la surveillance de capteurs ou de sources de données, etc.

Voici un exemple simple d'utilisation du Observer Pattern en Java :

```java
import java.util.ArrayList;
import java.util.List;

// Sujet (Observable)
interface Subject {
    void registerObserver(Observer observer);
    void removeObserver(Observer observer);
    void notifyObservers();
}

// Observateur (Observer)
interface Observer {
    void update(String message);
}

// Sujet concret (Concrete Subject)
class ConcreteSubject implements Subject {
    private List<Observer> observers = new ArrayList<>();
    private String state;

    public void setState(String state) {
        this.state = state;
        notifyObservers();
    }

    public void registerObserver(Observer observer) {
        observers.add(observer);
    }

    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }

    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(state);
        }
    }
}

// Observateur concret (Concrete Observer)
class ConcreteObserver implements Observer {
    private String observerName;

    public ConcreteObserver(String observerName) {
        this.observerName = observerName;
    }

    public void update(String message) {
        System.out.println(observerName + " received update: " + message);
    }
}

// Exemple d'utilisation du Observer Pattern
public class ObserverPatternExample {
    public static void main(String[] args) {
        ConcreteSubject subject = new ConcreteSubject();

        // Création d'observateurs
        ConcreteObserver observer1 = new ConcreteObserver("Observer 1");
        ConcreteObserver observer2 = new ConcreteObserver("Observer 2");

        // Enregistrement des observateurs auprès du sujet
        subject.registerObserver(observer1);
        subject.registerObserver(observer2);

        // Changement d'état du sujet
        subject.setState("New state!");
    }
}
```

Dans cet exemple :

- `Subject` est l'interface pour le sujet (ou observable) qui définit les méthodes pour enregistrer, supprimer et notifier les observateurs.
- `Observer` est l'interface pour les observateurs qui définit la méthode `update()` pour recevoir les mises à jour du sujet.
- `ConcreteSubject` est une implémentation concrète du sujet qui maintient une liste d'observateurs et les notifie lorsqu'un changement d'état se produit.
- `ConcreteObserver` est une implémentation concrète d'un observateur qui réagit aux mises à jour du sujet en affichant un message.
- Dans la classe `ObserverPatternExample`, nous créons un sujet, des observateurs, les enregistrons auprès du sujet, puis changeons l'état du sujet. Les observateurs sont automatiquement notifiés du changement d'état et réagissent en conséquence.