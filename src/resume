Fork/Join Framework (RecursiveAction, RecursiveTask, ForkJoinPool) :
Utilisé pour la division récursive d'une tâche en sous-tâches, adapté aux problèmes qui peuvent être résolus de manière récursive.
Exemple : Calcul parallèle de la somme d'un tableau.

ExecutorService (ThreadPoolExecutor, Executors) :
Utilisé pour gérer l'exécution asynchrone de tâches en utilisant des threads.
Exemple : Exécution simultanée de plusieurs tâches indépendantes.

CountDownLatch :
Utilisé lorsque vous avez besoin qu'un ou plusieurs threads attendent que d'autres threads aient terminé avant de continuer.
Exemple : Coordonner le départ d'une famille pour un voyage une fois que tous les membres sont prêts.

CyclicBarrier :
Utilisé lorsque vous avez besoin que plusieurs threads se synchronisent à un point donné pour continuer ensemble.
Exemple : Coordonner plusieurs équipes dans une course à étapes.

Semaphore :
Utilisé pour contrôler l'accès simultané à une ressource partagée par un nombre limité de threads.
Exemple : Contrôle de l'accès à un nombre limité de bols de nourriture pour des chiens dans une étable.

AtomicIntegerArray :
Utilisé lorsque vous avez besoin d'opérations atomiques sur un tableau d'entiers.
Exemple : Incrémentation atomique des éléments d'un tableau.

Exchanger :
Utilisé lorsque deux threads doivent échanger des données entre eux à un point de rencontre.
Exemple : Échange de voitures entre les clients et le garage pendant une réparation.

Phaser :
Utilisé lorsque vous avez besoin de synchroniser plusieurs threads à plusieurs points de rendez-vous dans un cycle.
Exemple : Coordonner les étapes d'un voyage à vélo en famille.
Choisissez la classe ou le mécanisme qui convient le mieux à votre problème spécifique en fonction des fonctionnalités offertes par chacun.


exemple de reentrant lock, liste partagée entre deux threads

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class SharedListProcessor extends Thread {
    private List<Integer> sharedList;
    private Lock lock;

    public SharedListProcessor(List<Integer> sharedList, Lock lock) {
        this.sharedList = sharedList;
        this.lock = lock;
    }

    public void run() {
        for (int i = 0; i < 5; i++) {
            try {
                lock.lock();
                sharedList.add(i);
                System.out.println(Thread.currentThread().getName() + " added: " + i);
            } finally {
                lock.unlock();
            }
        }
    }
}

public class ReentrantLockExample {
    public static void main(String[] args) {
        List<Integer> sharedList = new ArrayList<>();
        Lock lock = new ReentrantLock();

        SharedListProcessor thread1 = new SharedListProcessor(sharedList, lock);
        SharedListProcessor thread2 = new SharedListProcessor(sharedList, lock);

        thread1.start();
        thread2.start();

        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Shared List: " + sharedList);
    }
}


`ReadWriteLock` est une interface Java qui permet d'optimiser la gestion des accès en lecture et en écriture à une ressource partagée entre plusieurs threads. Elle permet à plusieurs threads de lire la ressource simultanément, mais garantit qu'un seul thread peut écrire dans la ressource à la fois. Voici quelques situations où l'utilisation de `ReadWriteLock` peut être appropriée :

1. **Lecture intensive, écriture peu fréquente** : Si la ressource est principalement lue par plusieurs threads, mais rarement mise à jour, l'utilisation de `ReadWriteLock` permet d'améliorer les performances en permettant la lecture simultanée par plusieurs threads.

2. **Réduction du verrouillage excessif** : Par rapport à l'utilisation d'un verrou traditionnel (par exemple, `ReentrantLock`) pour synchroniser à la fois la lecture et l'écriture, l'utilisation de `ReadWriteLock` peut réduire le verrouillage excessif en autorisant la lecture simultanée.

3. **Amélioration de la scalabilité** : L'utilisation de `ReadWriteLock` peut améliorer la scalabilité de l'application en permettant à plusieurs threads de lire la ressource en parallèle, ce qui peut réduire les temps d'attente et améliorer les performances globales.

4. **Protection contre les conditions de course en écriture** : En limitant l'accès en écriture à un seul thread à la fois, `ReadWriteLock` protège contre les conditions de course en écriture qui pourraient survenir lorsque plusieurs threads tentent de modifier la ressource simultanément.

En résumé, `ReadWriteLock` est particulièrement utile dans les cas où la lecture de la ressource est fréquente par rapport à l'écriture, et où la parallélisation de la lecture peut améliorer les performances globales de l'application.

`ReentrantReadWriteLock` est une implémentation de l'interface `ReadWriteLock` dans Java, qui fournit un mécanisme de verrouillage pour la gestion concurrente d'une ressource partagée, où plusieurs threads peuvent lire la ressource en même temps, mais l'accès en écriture est exclusif.

Voici quand utiliser `ReentrantReadWriteLock` :

1. **Accès intensif en lecture, accès en écriture moins fréquent** : Comme pour `ReadWriteLock`, `ReentrantReadWriteLock` est adapté aux situations où la ressource est principalement lue par plusieurs threads mais est rarement modifiée.

2. **Lecture optimisée** : `ReentrantReadWriteLock` offre des performances améliorées par rapport à l'utilisation d'un verrou standard pour la lecture et l'écriture. Il permet à plusieurs threads de lire la ressource en même temps, ce qui peut améliorer les performances dans les scénarios où la lecture est fréquente.

3. **Protection contre les conditions de course en écriture** : Comme avec `ReadWriteLock`, `ReentrantReadWriteLock` protège contre les conditions de course en écriture en permettant à un seul thread d'écrire dans la ressource à la fois.

4. **Compatibilité avec la réentrance** : Comme son nom l'indique, `ReentrantReadWriteLock` est réentrant, ce qui signifie qu'un thread qui détient déjà le verrou en lecture peut également acquérir le verrou en écriture, et vice versa, sans se bloquer.

5. **Flexibilité pour les cas où la réservation de verrou n'est pas nécessaire** : Contrairement à certains autres verrous, `ReentrantReadWriteLock` ne nécessite pas nécessairement la réservation d'un verrou avant de le libérer. Cette flexibilité peut être utile dans certains cas d'utilisation.

En résumé, `ReentrantReadWriteLock` est une option appropriée lorsque vous avez une ressource partagée avec une charge de lecture élevée et une charge d'écriture modérée, et que vous avez besoin d'une gestion de verrouillage concurrentielle et efficace.

Les `Lock.Condition` sont des objets associés à un verrou (`Lock`) qui permettent à un thread d'attendre qu'une certaine condition soit satisfaite avant de continuer son exécution. Ils sont utilisés en conjonction avec un verrou pour permettre une coordination plus fine entre les threads.

Voici quelques situations où vous pourriez utiliser `Lock.Condition` :

1. **Coordination entre threads** : Si un thread doit attendre qu'une certaine condition soit remplie avant de poursuivre son exécution, vous pouvez utiliser `Lock.Condition` pour suspendre son exécution jusqu'à ce que cette condition soit satisfaite.

2. **Synchronisation de tâches** : Vous pouvez utiliser `Lock.Condition` pour synchroniser l'exécution de plusieurs threads dans un ordre spécifique ou pour contrôler le flux d'exécution en fonction de certaines conditions.

3. **Gestion de files d'attente personnalisées** : Les conditions peuvent être utilisées pour implémenter des files d'attente personnalisées, où les threads peuvent attendre dans une file d'attente spécifique jusqu'à ce qu'une condition particulière soit remplie.

4. **Communication entre threads** : Les conditions peuvent être utilisées pour faciliter la communication entre threads en leur permettant d'attendre la notification d'un autre thread avant de poursuivre leur exécution.

Voici un exemple simple d'utilisation de `Lock.Condition` :

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class SharedResource {
    private boolean conditionMet = false;
    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();

    public void waitForCondition() throws InterruptedException {
        lock.lock();
        try {
            while (!conditionMet) {
                condition.await();
            }
            System.out.println("Condition is met!");
        } finally {
            lock.unlock();
        }
    }

    public void signalCondition() {
        lock.lock();
        try {
            conditionMet = true;
            condition.signal();
        } finally {
            lock.unlock();
        }
    }
}

public class ConditionExample {
    public static void main(String[] args) {
        SharedResource resource = new SharedResource();

        Thread waiterThread = new Thread(() -> {
            try {
                resource.waitForCondition();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        Thread signalerThread = new Thread(() -> {
            try {
                Thread.sleep(2000); // Simulate some delay
                resource.signalCondition();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        waiterThread.start();
        signalerThread.start();
    }
}
```

Dans cet exemple, un thread attend que la condition soit satisfaite à l'aide de `waitForCondition()`, tandis qu'un autre thread signale la condition à l'aide de `signalCondition()`.



Les `Executor` sont utilisés dans Java pour gérer l'exécution de tâches de manière asynchrone, souvent dans le contexte de programmation multithreadée. Voici quelques situations où vous pourriez utiliser des `Executor` :

1. **Exécution de tâches asynchrones** : Si vous avez des tâches qui peuvent être exécutées de manière asynchrone, comme des appels réseau, des calculs intensifs ou des opérations sur des fichiers, vous pouvez utiliser un `Executor` pour les exécuter en arrière-plan sans bloquer le thread principal.

2. **Gestion des threads** : Les `Executor` simplifient la gestion des threads en fournissant une interface de haut niveau pour l'exécution de tâches. Vous n'avez pas besoin de créer et de gérer manuellement des threads, ce qui réduit les risques d'erreurs liées à la gestion des threads.

3. **Contrôle du nombre de threads** : Les `Executor` permettent de contrôler facilement le nombre de threads utilisés pour exécuter les tâches. Vous pouvez utiliser des implémentations spécifiques d'`Executor`, comme `ThreadPoolExecutor`, pour configurer le pool de threads en fonction des besoins de votre application.

4. **Gestion de la file d'attente des tâches** : Les `Executor` fournissent une file d'attente pour les tâches en attente d'exécution. Cela permet de lisser la charge de travail et d'éviter la surcharge des ressources système en cas de forte demande.

5. **Gestion des erreurs** : Les `Executor` fournissent des mécanismes pour gérer les erreurs survenues lors de l'exécution des tâches, ce qui facilite la gestion des exceptions dans les applications multithreadées.

6. **Planification des tâches récurrentes** : Certains `Executor` offrent la possibilité de planifier l'exécution de tâches de manière récurrente, ce qui peut être utile pour les tâches périodiques telles que la génération de rapports ou la maintenance des données.

En résumé, vous pouvez utiliser des `Executor` chaque fois que vous avez besoin d'exécuter des tâches de manière asynchrone, de contrôler le nombre de threads utilisés pour exécuter ces tâches et de gérer les erreurs qui peuvent survenir pendant leur exécution. Ils offrent une abstraction puissante pour la gestion des threads et facilitent le développement d'applications multithreadées robustes et performantes.




Voici un exemple où nous utilisons `Callable` pour calculer la somme des éléments d'un tableau de manière asynchrone à l'aide d'un `ExecutorService` :

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

class SumCalculator implements Callable<Integer> {
    private int[] array;
    private int startIndex;
    private int endIndex;

    public SumCalculator(int[] array, int startIndex, int endIndex) {
        this.array = array;
        this.startIndex = startIndex;
        this.endIndex = endIndex;
    }

    public Integer call() {
        int sum = 0;
        for (int i = startIndex; i < endIndex; i++) {
            sum += array[i];
        }
        return sum;
    }
}

public class CallableExample {
    public static void main(String[] args) {
        int[] array = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        int numThreads = 4;
        ExecutorService executor = Executors.newFixedThreadPool(numThreads);

        int blockSize = array.length / numThreads;
        int startIndex = 0;
        int endIndex = blockSize;

        // Soumission des tâches Callable à l'ExecutorService
        Future<Integer>[] futures = new Future[numThreads];
        for (int i = 0; i < numThreads; i++) {
            if (i == numThreads - 1) {
                endIndex = array.length;
            }
            SumCalculator calculator = new SumCalculator(array, startIndex, endIndex);
            futures[i] = executor.submit(calculator);
            startIndex = endIndex;
            endIndex += blockSize;
        }

        // Attente et récupération des résultats
        int totalSum = 0;
        try {
            for (Future<Integer> future : futures) {
                totalSum += future.get();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        System.out.println("Total sum: " + totalSum);

        // Arrêt de l'ExecutorService
        executor.shutdown();
    }
}
```

Dans cet exemple :

- Nous créons une classe `SumCalculator` qui implémente `Callable<Integer>`. Cette classe calcule la somme des éléments d'un sous-tableau.
- Nous créons un `ExecutorService` avec un pool de threads de taille fixe.
- Nous découpons le tableau en plusieurs sous-tableaux et soumettons chaque tâche `SumCalculator` à l'`ExecutorService` pour calculer la somme de chaque sous-tableau.
- Nous utilisons `Future.get()` pour attendre que chaque tâche se termine et obtenir le résultat.
- Nous calculons la somme totale à partir des résultats partiels des tâches et affichons le résultat final.


Voici un exemple simple d'une file d'attente avec verrouillage en Java, où nous avons un producteur qui produit des éléments dans la file d'attente et un consommateur qui les consomme :

```java
import java.util.LinkedList;
import java.util.Queue;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class BlockingQueue<T> {
    private Queue<T> queue;
    private int capacity;
    private Lock lock;
    private Condition notFull;
    private Condition notEmpty;

    public BlockingQueue(int capacity) {
        this.capacity = capacity;
        queue = new LinkedList<>();
        lock = new ReentrantLock();
        notFull = lock.newCondition();
        notEmpty = lock.newCondition();
    }

    public void enqueue(T item) throws InterruptedException {
        lock.lock();
        try {
            while (queue.size() == capacity) {
                notFull.await();
            }
            queue.offer(item);
            notEmpty.signal();
        } finally {
            lock.unlock();
        }
    }

    public T dequeue() throws InterruptedException {
        lock.lock();
        try {
            while (queue.isEmpty()) {
                notEmpty.await();
            }
            T item = queue.poll();
            notFull.signal();
            return item;
        } finally {
            lock.unlock();
        }
    }
}

class Producer implements Runnable {
    private BlockingQueue<Integer> queue;

    public Producer(BlockingQueue<Integer> queue) {
        this.queue = queue;
    }

    public void run() {
        try {
            for (int i = 0; i < 10; i++) {
                System.out.println("Producing: " + i);
                queue.enqueue(i);
                Thread.sleep(1000); // Simulate some work
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

class Consumer implements Runnable {
    private BlockingQueue<Integer> queue;

    public Consumer(BlockingQueue<Integer> queue) {
        this.queue = queue;
    }

    public void run() {
        try {
            for (int i = 0; i < 10; i++) {
                int item = queue.dequeue();
                System.out.println("Consuming: " + item);
                Thread.sleep(2000); // Simulate some work
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

public class BlockingQueueExample {
    public static void main(String[] args) {
        BlockingQueue<Integer> queue = new BlockingQueue<>(5);

        Thread producerThread = new Thread(new Producer(queue));
        Thread consumerThread = new Thread(new Consumer(queue));

        producerThread.start();
        consumerThread.start();
    }
}
```

Dans cet exemple :

- `BlockingQueue` est une file d'attente avec verrouillage qui peut enregistrer un nombre fixe d'éléments.
- La classe `Producer` produit des éléments et les ajoute à la file d'attente à l'aide de la méthode `enqueue()`.
- La classe `Consumer` consomme des éléments de la file d'attente à l'aide de la méthode `dequeue()`.
- Les threads `Producer` et `Consumer` sont créés et démarrés, et ils produisent et consomment des éléments de manière asynchrone, synchronisée par le verrou de la file d'attente.


Bien sûr ! Voici un exemple pratique où nous utilisons le Singleton pour gérer une connexion à une base de données dans une application Java :

```java
// Classe Singleton de gestion de la connexion à la base de données
public class DatabaseConnection {
    // Instance unique de la classe Singleton
    private static DatabaseConnection instance;

    // Attributs de connexion à la base de données
    private String url;
    private String username;
    private String password;

    // Constructeur privé pour empêcher l'instanciation depuis l'extérieur de la classe
    private DatabaseConnection() {
        // Initialisation des attributs de connexion (exemple)
        url = "jdbc:mysql://localhost:3306/mydatabase";
        username = "root";
        password = "password";
    }

    // Méthode statique pour accéder à l'instance unique du Singleton
    public static synchronized DatabaseConnection getInstance() {
        // Crée l'instance si elle n'existe pas encore
        if (instance == null) {
            instance = new DatabaseConnection();
        }
        return instance;
    }

    // Méthode pour établir la connexion à la base de données (exemple)
    public void connect() {
        System.out.println("Connecting to database...");
        // Code pour établir la connexion à la base de données
        System.out.println("Connected to database: " + url);
    }

    // Autres méthodes pour manipuler la connexion à la base de données
    // ...
}

// Exemple d'utilisation du Singleton dans une application
public class Main {
    public static void main(String[] args) {
        // Accès à l'instance unique du Singleton
        DatabaseConnection databaseConnection = DatabaseConnection.getInstance();

        // Connexion à la base de données
        databaseConnection.connect();
    }
}
```

Dans cet exemple :

- La classe `DatabaseConnection` représente le Singleton qui gère la connexion à la base de données.
- La méthode `getInstance()` fournit un point d'accès global à l'instance unique de `DatabaseConnection`. Si aucune instance n'existe encore, cette méthode crée une nouvelle instance en appelant le constructeur privé.
- La méthode `connect()` est un exemple d'une opération que vous pourriez effectuer avec votre connexion à la base de données. Dans cet exemple, elle affiche simplement un message de connexion réussie.
- Dans la classe `Main`, nous accédons à l'instance unique de `DatabaseConnection` en appelant `DatabaseConnection.getInstance()`, puis nous utilisons cette instance pour établir une connexion à la base de données en appelant `connect()`.

Le Proxy Pattern est un patron de conception structurel qui permet de contrôler l'accès à un objet en agissant comme une interface de remplacement ou un point d'accès à cet objet. Il peut être utilisé pour ajouter une couche d'abstraction et de contrôle supplémentaire autour d'un objet réel, en fournissant une interface similaire à celle de l'objet réel.

Voici les principaux acteurs impliqués dans le Proxy Pattern :

1. **Sujet (Subject)** : C'est l'interface commune entre le client et le proxy, décrivant les opérations que le client peut appeler sur l'objet réel.

2. **Proxy** : Il implémente l'interface du sujet et contrôle l'accès à l'objet réel. Le proxy intercepte les appels du client et peut effectuer des opérations supplémentaires avant ou après de rediriger les appels à l'objet réel.

3. **Objet réel (Real Subject)** : C'est l'objet réel qui effectue le travail réel, mais qui est caché derrière le proxy. Le client n'a pas besoin de connaître l'existence de l'objet réel.

Le Proxy Pattern est utile dans les cas suivants :

- **Contrôle d'accès** : Pour limiter l'accès à certaines fonctionnalités de l'objet réel.
- **Chargement paresseux (Lazy Loading)** : Pour retarder le chargement d'un objet lourd en mémoire jusqu'à ce qu'il soit vraiment nécessaire.
- **Mise en cache** : Pour mettre en cache les résultats des opérations coûteuses et les fournir directement si elles ont déjà été calculées.
- **Journalisation ou surveillance** : Pour journaliser les appels ou surveiller les opérations effectuées sur l'objet réel.

Voici un exemple d'utilisation du Proxy Pattern en Java pour implémenter un proxy pour l'accès à des fichiers sur le système de fichiers :

```java
// Sujet (interface)
interface File {
    void read();
}

// Objet réel
class RealFile implements File {
    private String fileName;

    public RealFile(String fileName) {
        this.fileName = fileName;
        loadFromDisk();
    }

    private void loadFromDisk() {
        System.out.println("Loading file: " + fileName);
    }

    public void read() {
        System.out.println("Reading file: " + fileName);
    }
}

// Proxy
class ProxyFile implements File {
    private String fileName;
    private RealFile realFile;

    public ProxyFile(String fileName) {
        this.fileName = fileName;
    }

    public void read() {
        // Crée l'objet réel lors du premier appel
        if (realFile == null) {
            realFile = new RealFile(fileName);
        }
        // Appelle la méthode read() de l'objet réel
        realFile.read();
    }
}

// Exemple d'utilisation du Proxy Pattern
public class ProxyPatternExample {
    public static void main(String[] args) {
        // Utilisation du proxy pour accéder à un fichier
        File file = new ProxyFile("example.txt");

        // Lecture du fichier
        file.read();
    }
}
```

Dans cet exemple :

- `File` est l'interface commune entre le client et le proxy.
- `RealFile` est l'objet réel qui représente un fichier sur le système de fichiers.
- `ProxyFile` est le proxy qui contrôle l'accès au fichier réel. Il intercepte les appels de lecture et charge le fichier réel lors du premier appel à la méthode `read()`.
- Dans la classe `ProxyPatternExample`, nous utilisons le proxy pour accéder à un fichier, en utilisant l'interface commune `File`. Lorsque nous appelons la méthode `read()` sur le proxy, il charge le fichier réel si nécessaire, puis appelle la méthode `read()` sur l'objet réel pour lire le fichier.



Le Observer Pattern est un patron de conception comportemental qui permet à un objet, appelé le sujet (ou observable), de publier des changements à d'autres objets, appelés les observateurs, de manière automatique. Ce pattern est utilisé lorsque vous avez une relation un-à-plusieurs entre les objets, de sorte que lorsque l'état d'un objet change, tous ses observateurs sont notifiés et mis à jour automatiquement.

Voici les acteurs principaux du Observer Pattern :

1. **Sujet (Observable)** : Il est responsable de maintenir une liste d'observateurs et de les notifier lorsque son état change.

2. **Observateur (Observer)** : Il définit une interface de mise à jour pour les objets qui doivent être notifiés des changements d'état du sujet.

3. **Observateurs concrets (Concrete Observers)** : Ils implémentent l'interface Observateur et réagissent aux notifications émises par le sujet.

Le Observer Pattern est utilisé dans de nombreuses situations, telles que la mise à jour de l'interface utilisateur en réponse aux changements de modèle, la mise en œuvre de la publication-abonnement, la surveillance de capteurs ou de sources de données, etc.

Voici un exemple simple d'utilisation du Observer Pattern en Java :

```java
import java.util.ArrayList;
import java.util.List;

// Sujet (Observable)
interface Subject {
    void registerObserver(Observer observer);
    void removeObserver(Observer observer);
    void notifyObservers();
}

// Observateur (Observer)
interface Observer {
    void update(String message);
}

// Sujet concret (Concrete Subject)
class ConcreteSubject implements Subject {
    private List<Observer> observers = new ArrayList<>();
    private String state;

    public void setState(String state) {
        this.state = state;
        notifyObservers();
    }

    public void registerObserver(Observer observer) {
        observers.add(observer);
    }

    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }

    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(state);
        }
    }
}

// Observateur concret (Concrete Observer)
class ConcreteObserver implements Observer {
    private String observerName;

    public ConcreteObserver(String observerName) {
        this.observerName = observerName;
    }

    public void update(String message) {
        System.out.println(observerName + " received update: " + message);
    }
}

// Exemple d'utilisation du Observer Pattern
public class ObserverPatternExample {
    public static void main(String[] args) {
        ConcreteSubject subject = new ConcreteSubject();

        // Création d'observateurs
        ConcreteObserver observer1 = new ConcreteObserver("Observer 1");
        ConcreteObserver observer2 = new ConcreteObserver("Observer 2");

        // Enregistrement des observateurs auprès du sujet
        subject.registerObserver(observer1);
        subject.registerObserver(observer2);

        // Changement d'état du sujet
        subject.setState("New state!");
    }
}



Voici une implémentation possible de la gestion d'une connexion à une base de données en utilisant le Singleton et en assurant un accès sûr et thread-safe :

```java
public class DatabaseConnection {
    private static volatile DatabaseConnection instance; // Utilisation de volatile pour assurer la visibilité entre threads
    private static Object lock = new Object(); // Verrou pour le double verrouillage
    private String url;
    private String username;
    private String password;

    // Constructeur privé pour empêcher l'instanciation directe
    private DatabaseConnection() {
        // Initialisation de la connexion à la base de données
        this.url = "jdbc:mysql://localhost:3306/mydatabase";
        this.username = "username";
        this.password = "password";
    }

    // Méthode pour obtenir l'instance unique du Singleton
    public static DatabaseConnection getInstance() {
        if (instance == null) {
            synchronized (lock) {
                if (instance == null) {
                    instance = new DatabaseConnection();
                }
            }
        }
        return instance;
    }

    // Autres méthodes pour interagir avec la connexion à la base de données
    public void connect() {
        System.out.println("Connecting to database...");
        // Code pour établir la connexion à la base de données
        System.out.println("Connected to database: " + url);
    }

    public void disconnect() {
        System.out.println("Disconnecting from database...");
        // Code pour fermer la connexion à la base de données
        System.out.println("Disconnected from database.");
    }
}
```

Dans cette implémentation :

- Nous avons une classe `DatabaseConnection` qui représente notre Singleton pour gérer la connexion à la base de données.
- Le constructeur est privé pour empêcher l'instanciation directe depuis l'extérieur de la classe.
- La méthode `getInstance()` est statique et synchronisée pour assurer que l'accès à l'instance est thread-safe. Nous utilisons le double verrouillage pour minimiser les coûts de synchronisation une fois que l'instance a été créée.
- Nous utilisons le mot-clé `volatile` pour la variable `instance` afin de garantir que les modifications apportées à cette variable sont visibles pour tous les threads.
- Les autres méthodes de la classe (comme `connect()` et `disconnect()`) peuvent être utilisées pour interagir avec la connexion à la base de données une fois que l'instance Singleton est obtenue.

Avec cette implémentation, chaque thread qui demande une instance de `DatabaseConnection` obtiendra la même instance unique, et l'accès à cette instance est thread-safe grâce à la synchronisation.
```

Dans cet exemple :

- `Subject` est l'interface pour le sujet (ou observable) qui définit les méthodes pour enregistrer, supprimer et notifier les observateurs.
- `Observer` est l'interface pour les observateurs qui définit la méthode `update()` pour recevoir les mises à jour du sujet.
- `ConcreteSubject` est une implémentation concrète du sujet qui maintient une liste d'observateurs et les notifie lorsqu'un changement d'état se produit.
- `ConcreteObserver` est une implémentation concrète d'un observateur qui réagit aux mises à jour du sujet en affichant un message.
- Dans la classe `ObserverPatternExample`, nous créons un sujet, des observateurs, les enregistrons auprès du sujet, puis changeons l'état du sujet. Les observateurs sont automatiquement notifiés du changement d'état et réagissent en conséquence.

Voici une implémentation possible du simulateur de système de surveillance de capteurs en utilisant le Observer Pattern et les Threads en Java :

```java
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

// Sujet (Observable) : représente un capteur
class Sensor implements Runnable {
    private List<Observer> observers = new ArrayList<>();
    private Random random = new Random();
    private boolean running;

    public void addObserver(Observer observer) {
        observers.add(observer);
    }

    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }

    public void start() {
        running = true;
        new Thread(this).start();
    }

    public void stop() {
        running = false;
    }

    @Override
    public void run() {
        while (running) {
            int data = random.nextInt(100); // Génère des données aléatoires
            notifyObservers(data); // Notifie les observateurs avec les nouvelles données
            try {
                Thread.sleep(1000); // Attente de 1 seconde entre chaque génération de données
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    private void notifyObservers(int data) {
        for (Observer observer : observers) {
            observer.update(data);
        }
    }
}

// Observateur (Observer) : représente un module de traitement
class Processor implements Observer {
    private String name;

    public Processor(String name) {
        this.name = name;
    }

    @Override
    public void update(int data) {
        System.out.println(name + " received data: " + data);
        // Effectue un traitement sur les données
    }
}

// Interface Observer
interface Observer {
    void update(int data);
}

// Exemple d'utilisation du simulateur de système de surveillance de capteurs
public class SensorSimulation {
    public static void main(String[] args) {
        Sensor sensor = new Sensor();

        // Création de plusieurs observateurs (processors) et ajout à la liste des observateurs du capteur
        Processor processor1 = new Processor("Processor 1");
        Processor processor2 = new Processor("Processor 2");

        sensor.addObserver(processor1);
        sensor.addObserver(processor2);

        // Démarrage du capteur (observable)
        sensor.start();

        // Attend quelques secondes avant d'arrêter la simulation
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // Arrêt du capteur (observable)
        sensor.stop();
    }
}
```

Dans cette implémentation :

- La classe `Sensor` représente le sujet (Observable) qui simule un capteur générant des données à intervalles réguliers.
- Les observateurs (Observers) sont représentés par la classe `Processor`, qui réagit aux nouvelles données générées par le capteur.
- Les observateurs sont exécutés dans des threads séparés lorsqu'ils sont ajoutés à la liste des observateurs du capteur.
- Lorsque le capteur génère de nouvelles données, il notifie tous les observateurs en appelant leur méthode `update()`.
- La classe `SensorSimulation` démontre l'utilisation du simulateur de système de surveillance de capteurs en créant un capteur, en ajoutant des observateurs, en démarrant le capteur, en attendant quelques secondes, puis en arrêtant le capteur.


Voici une implémentation possible d'un proxy pour limiter l'accès concurrent à une ressource partagée en utilisant le Proxy Pattern et les Threads en Java :

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

// Interface pour la ressource partagée
interface Resource {
    void accessResource();
}

// Classe concrète représentant la ressource partagée
class ConcreteResource implements Resource {
    @Override
    public void accessResource() {
        System.out.println("Accessing shared resource...");
        // Code pour accéder à la ressource partagée
        System.out.println("Done accessing shared resource.");
    }
}

// Proxy pour limiter l'accès concurrent à la ressource partagée
class ProxyResource implements Resource {
    private Resource realResource;
    private Lock lock = new ReentrantLock(); // Verrou pour contrôler l'accès concurrent

    public ProxyResource() {
        this.realResource = new ConcreteResource();
    }

    @Override
    public void accessResource() {
        lock.lock(); // Acquérir le verrou
        try {
            realResource.accessResource(); // Accès à la ressource partagée
        } finally {
            lock.unlock(); // Libérer le verrou
        }
    }
}

// Exemple d'utilisation du proxy pour limiter l'accès concurrent à la ressource partagée
public class ProxyPatternWithThreads {
    public static void main(String[] args) {
        final int NUM_THREADS = 5;
        ProxyResource proxy = new ProxyResource();

        // Création et démarrage des threads pour accéder à la ressource partagée
        for (int i = 0; i < NUM_THREADS; i++) {
            Thread thread = new Thread(() -> proxy.accessResource());
            thread.start();
        }
    }
}
```

Dans cette implémentation :

- L'interface `Resource` définit les opérations que les utilisateurs peuvent effectuer sur la ressource partagée.
- La classe concrète `ConcreteResource` représente la ressource partagée réelle avec la méthode `accessResource()` qui accède à la ressource.
- Le proxy `ProxyResource` contrôle l'accès à la ressource partagée en utilisant un verrou (`ReentrantLock`) pour garantir un accès concurrent sûr.
- Dans la méthode `accessResource()` du proxy, le verrou est acquis avant d'accéder à la ressource réelle et est libéré après avoir terminé l'accès à la ressource.
- Dans la classe `ProxyPatternWithThreads`, plusieurs threads sont créés pour accéder simultanément au proxy, ce qui démontre l'accès concurrent limité à la ressource partagée.


Voici une implémentation possible du système de journalisation pour une application multi-thread en combinant le Singleton et le Observer Pattern en Java :

```java
import java.util.ArrayList;
import java.util.List;

// Singleton représentant le journal de l'application
class Logger {
    private static volatile Logger instance; // Utilisation de volatile pour garantir la visibilité entre threads
    private List<Observer> observers = new ArrayList<>();

    // Constructeur privé pour empêcher l'instanciation directe
    private Logger() {}

    // Méthode pour obtenir l'instance unique du Singleton
    public static Logger getInstance() {
        if (instance == null) {
            synchronized (Logger.class) {
                if (instance == null) {
                    instance = new Logger();
                }
            }
        }
        return instance;
    }

    // Méthode pour ajouter un observateur au journal
    public void addObserver(Observer observer) {
        observers.add(observer);
    }

    // Méthode pour enlever un observateur du journal
    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }

    // Méthode pour enregistrer un événement dans le journal
    public void logEvent(String event) {
        System.out.println("Logging event: " + event);
        // Notifier tous les observateurs avec l'événement enregistré
        notifyObservers(event);
    }

    // Méthode pour notifier tous les observateurs avec un événement
    private void notifyObservers(String event) {
        for (Observer observer : observers) {
            observer.update(event);
        }
    }
}

// Interface pour les observateurs surveillant les événements de l'application
interface Observer {
    void update(String event);
}

// Observateur représentant un module de surveillance des erreurs
class ErrorLogger implements Observer {
    @Override
    public void update(String event) {
        if (event.contains("ERROR")) {
            System.out.println("ErrorLogger: " + event);
        }
    }
}

// Observateur représentant un module de surveillance des performances
class PerformanceLogger implements Observer {
    @Override
    public void update(String event) {
        if (event.contains("PERFORMANCE")) {
            System.out.println("PerformanceLogger: " + event);
        }
    }
}

// Exemple d'utilisation du système de journalisation pour une application multi-thread
public class LoggingSystem {
    public static void main(String[] args) {
        Logger logger = Logger.getInstance();

        // Ajout d'observateurs (modules de surveillance) au journal
        logger.addObserver(new ErrorLogger());
        logger.addObserver(new PerformanceLogger());

        // Simulation de l'enregistrement d'événements dans l'application multi-thread
        Thread thread1 = new Thread(() -> logger.logEvent("ERROR: Something went wrong!"));
        Thread thread2 = new Thread(() -> logger.logEvent("INFO: Application started."));
        Thread thread3 = new Thread(() -> logger.logEvent("PERFORMANCE: Processing took 500ms."));

        thread1.start();
        thread2.start();
        thread3.start();
    }
}
```

Dans cette implémentation :

- La classe `Logger` est un Singleton représentant le journal de l'application. Elle enregistre les événements de l'application et notifie les observateurs de ces événements.
- Les observateurs (`ErrorLogger` et `PerformanceLogger`) surveillent différents aspects de l'application (erreurs et performances) et réagissent aux événements enregistrés dans le journal.
- Les observateurs sont ajoutés au journal à l'aide de la méthode `addObserver()` et sont notifiés de chaque événement enregistré à l'aide de la méthode `notifyObservers()`.
- Dans la classe `LoggingSystem`, plusieurs threads sont créés pour simuler l'enregistrement concurrent d'événements dans l'application, démontrant ainsi l'utilisation du système de journalisation dans un environnement multi-thread.


Exercice combinant plusieurs Design Patterns :

Demandez aux étudiants de concevoir et d'implémenter un système de traitement de commandes en ligne.
Ils peuvent utiliser des design patterns tels que Factory Method pour créer différentes commandes, Singleton pour gérer le panier d'achats de l'utilisateur de manière unique, Observer pour suivre l'état de la commande en temps réel, etc.

Voici une implémentation possible d'un système de traitement de commandes en ligne en combinant plusieurs design patterns en Java :

```java
import java.util.ArrayList;
import java.util.List;

// Produit représentant un article dans une commande
class Product {
    private String name;
    private double price;

    public Product(String name, double price) {
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }
}

// Interface pour les commandes
interface Order {
    void addProduct(Product product);
    double calculateTotal();
}

// Commande concrète
class ConcreteOrder implements Order {
    private List<Product> products = new ArrayList<>();

    public void addProduct(Product product) {
        products.add(product);
    }

    public double calculateTotal() {
        double total = 0;
        for (Product product : products) {
            total += product.getPrice();
        }
        return total;
    }
}

// Interface pour le panier d'achats
interface ShoppingCart {
    void addToCart(Product product);
    double getTotal();
}

// Singleton représentant le panier d'achats de l'utilisateur
class ShoppingCartManager implements ShoppingCart {
    private static ShoppingCartManager instance;
    private List<Product> cart = new ArrayList<>();

    private ShoppingCartManager() {}

    public static synchronized ShoppingCartManager getInstance() {
        if (instance == null) {
            instance = new ShoppingCartManager();
        }
        return instance;
    }

    public void addToCart(Product product) {
        cart.add(product);
    }

    public double getTotal() {
        double total = 0;
        for (Product product : cart) {
            total += product.getPrice();
        }
        return total;
    }
}

// Observateur pour suivre l'état de la commande en temps réel
class OrderObserver {
    public void update(Order order) {
        System.out.println("Order total: " + order.calculateTotal());
    }
}

// Factory Method pour créer différentes commandes
class OrderFactory {
    public static Order createOrder() {
        return new ConcreteOrder();
    }
}

// Exemple d'utilisation du système de traitement de commandes en ligne
public class OnlineOrderSystem {
    public static void main(String[] args) {
        // Création d'un produit
        Product product1 = new Product("Product 1", 10.0);

        // Ajout du produit au panier d'achats
        ShoppingCart shoppingCart = ShoppingCartManager.getInstance();
        shoppingCart.addToCart(product1);

        // Calcul du total du panier d'achats
        System.out.println("Total in shopping cart: " + shoppingCart.getTotal());

        // Création d'une commande à partir du panier d'achats
        Order order = OrderFactory.createOrder();
        for (Product product : ((ShoppingCartManager) shoppingCart).cart) {
            order.addProduct(product);
        }

        // Observateur pour suivre l'état de la commande en temps réel
        OrderObserver observer = new OrderObserver();
        observer.update(order);
    }
}
```

Dans cette implémentation :

- Nous avons des classes représentant des produits, des commandes, un panier d'achats et un gestionnaire de panier d'achats en utilisant le Singleton.
- Le Factory Method est utilisé pour créer différentes commandes.
- Un observateur est utilisé pour suivre l'état de la commande en temps réel.
- L'exemple d'utilisation dans la classe `OnlineOrderSystem` démontre comment ajouter des produits au panier d'achats, créer une commande à partir du panier d'achats, et suivre l'état de la commande à l'aide de l'observateur.